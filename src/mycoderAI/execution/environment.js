/**
 * Execution Environment
 * Version: 0.2.0
 * Date: 2025-03-03
 * Author: Forge, DevOps Lead
 * 
 * The Execution Environment provides direct system-level access for executing code
 * generated by agents. It focuses on maximum performance and flexibility with
 * full system access for all agents.
 */

'use strict';

const EventEmitter = require('events');
const { exec, spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const util = require('util');
const crypto = require('crypto');
const { Readable } = require('stream');

// Promisified exec
const execPromise = util.promisify(exec);

// Supported languages and their configurations
const SUPPORTED_LANGUAGES = {
  javascript: {
    extension: 'js',
    command: 'node',
    runFile: true
  },
  typescript: {
    extension: 'ts',
    command: 'ts-node',
    runFile: true
  },
  python: {
    extension: 'py',
    command: 'python3',
    runFile: true
  },
  bash: {
    extension: 'sh',
    command: 'bash',
    runFile: true
  },
  json: {
    extension: 'json',
    command: 'cat',
    runFile: true
  },
  text: {
    extension: 'txt',
    command: 'cat',
    runFile: true
  }
};

// Execution timeouts (in milliseconds) - extended for performance
const EXECUTION_TIMEOUTS = {
  default: 60000,  // 1 minute
  long: 300000,    // 5 minutes
  short: 30000     // 30 seconds
};

class ExecutionEnvironment extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = options;
    this.logger = options.logger;
    
    this.baseDirectory = options.baseDirectory || './execution';
    this.tempDirectory = path.join(this.baseDirectory, 'temp');
    this.outputDirectory = path.join(this.baseDirectory, 'output');
    
    // Map to track running processes
    this.runningProcesses = new Map();
    
    // Default timeout
    this.defaultTimeout = options.defaultTimeout || EXECUTION_TIMEOUTS.default;
    
    // Execution count for metrics
    this.executionCount = 0;
    this.successCount = 0;
    this.failureCount = 0;
    
    this.status = {
      initialized: false,
      ready: false
    };
    
    this.logger.info('Execution Environment created with full system access');
  }
  
  /**
   * Initialize the execution environment
   */
  async initialize() {
    this.logger.info('Initializing Execution Environment with full system access...');
    
    try {
      // Create required directories
      await fs.mkdir(this.baseDirectory, { recursive: true });
      await fs.mkdir(this.tempDirectory, { recursive: true });
      await fs.mkdir(this.outputDirectory, { recursive: true });
      
      // Verify commands are available
      await this._verifyDependencies();
      
      this.status.initialized = true;
      this.status.ready = true;
      
      this.logger.info('Execution Environment initialized with full system access');
      
      // Emit initialization event
      this.emit('initialized', {
        baseDirectory: this.baseDirectory,
        tempDirectory: this.tempDirectory,
        outputDirectory: this.outputDirectory
      });
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize Execution Environment:', error);
      throw error;
    }
  }
  
  /**
   * Verify that required dependencies are available
   */
  async _verifyDependencies() {
    this.logger.info('Verifying dependencies...');
    
    const requiredCommands = new Set([
      'node',
      'python3',
      'bash',
      'cat'
    ]);
    
    // Optional commands
    const optionalCommands = new Set([
      'ts-node'
    ]);
    
    // Check required commands
    for (const command of requiredCommands) {
      try {
        await execPromise(`which ${command}`);
        this.logger.info(`Dependency verified: ${command}`);
      } catch (error) {
        this.logger.error(`Required dependency not found: ${command}`);
        throw new Error(`Required dependency not found: ${command}`);
      }
    }
    
    // Check optional commands
    for (const command of optionalCommands) {
      try {
        await execPromise(`which ${command}`);
        this.logger.info(`Optional dependency verified: ${command}`);
      } catch (error) {
        this.logger.warn(`Optional dependency not found: ${command}`);
        
        // If ts-node is missing, remove TypeScript from supported languages
        if (command === 'ts-node') {
          delete SUPPORTED_LANGUAGES.typescript;
        }
      }
    }
    
    return true;
  }
  
  /**
   * Generate a unique execution ID
   */
  _generateExecutionId() {
    return crypto.randomBytes(8).toString('hex');
  }
  
  /**
   * Create a temporary file for code execution
   */
  async _createTempFile(code, language) {
    const executionId = this._generateExecutionId();
    const langConfig = SUPPORTED_LANGUAGES[language];
    
    if (!langConfig) {
      throw new Error(`Unsupported language: ${language}`);
    }
    
    const extension = langConfig.extension;
    const filePath = path.join(this.tempDirectory, `${executionId}.${extension}`);
    
    // Write code to temp file
    await fs.writeFile(filePath, code);
    
    return {
      executionId,
      filePath
    };
  }
  
  /**
   * Clean up temporary files after execution
   */
  async _cleanupTempFiles(executionId, filePath) {
    try {
      await fs.unlink(filePath);
      this.logger.info(`Cleaned up temp file for execution ${executionId}`);
    } catch (error) {
      this.logger.warn(`Failed to clean up temp file for execution ${executionId}:`, error);
    }
  }
  
  /**
   * Execute code with full system access
   */
  async executeCode(code, language = 'javascript', inputs = {}, options = {}) {
    this.logger.info(`Executing ${language} code with full system access...`);
    
    // Check if environment is initialized
    if (!this.status.initialized) {
      throw new Error('Execution Environment not initialized');
    }
    
    // Verify language is supported
    if (!SUPPORTED_LANGUAGES[language]) {
      throw new Error(`Unsupported language: ${language}`);
    }
    
    // Generate execution ID and create temp file
    const { executionId, filePath } = await this._createTempFile(code, language);
    
    // Increment execution count
    this.executionCount++;
    
    // Set timeout
    const timeout = options.timeout || this.defaultTimeout;
    
    this.logger.info(`Executing ${language} code (ID: ${executionId}) with full system access`);
    
    try {
      // Execute the code directly with full system access
      const result = await this._executeWithSystemAccess(executionId, filePath, language, inputs, timeout);
      
      // Increment success count
      this.successCount++;
      
      // Clean up temp files
      await this._cleanupTempFiles(executionId, filePath);
      
      return {
        executionId,
        success: true,
        result: result,
        language,
        executionTime: result.executionTime
      };
    } catch (error) {
      // Increment failure count
      this.failureCount++;
      
      this.logger.error(`Execution error (ID: ${executionId}):`, error);
      
      // Clean up temp files
      await this._cleanupTempFiles(executionId, filePath);
      
      return {
        executionId,
        success: false,
        error: error.message,
        language
      };
    }
  }
  
  /**
   * Execute code directly with full system access
   */
  async _executeWithSystemAccess(executionId, filePath, language, inputs = {}, timeout) {
    return new Promise((resolve, reject) => {
      const langConfig = SUPPORTED_LANGUAGES[language];
      const command = langConfig.command;
      const args = langConfig.runFile ? [filePath] : [];
      
      // Prepare input data as environment variables
      const env = { ...process.env };
      
      // Convert inputs to environment variables
      if (inputs && typeof inputs === 'object') {
        Object.entries(inputs).forEach(([key, value]) => {
          if (typeof value === 'string') {
            env[`INPUT_${key.toUpperCase()}`] = value;
          } else {
            env[`INPUT_${key.toUpperCase()}`] = JSON.stringify(value);
          }
        });
      }
      
      // Create process with full system access
      const startTime = Date.now();
      const childProcess = spawn(command, args, {
        env,
        cwd: process.cwd(), // Use current working directory for full system access
        stdio: ['pipe', 'pipe', 'pipe']
      });
      
      // Track the process
      this.runningProcesses.set(executionId, childProcess);
      
      // Set up result collection
      let stdout = '';
      let stderr = '';
      
      // Collect stdout
      childProcess.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      // Collect stderr
      childProcess.stderr.on('data', (data) => {
        stderr += data.toString();
      });
      
      // Handle process completion
      childProcess.on('close', (code) => {
        const executionTime = Date.now() - startTime;
        
        // Remove from tracking
        this.runningProcesses.delete(executionId);
        
        if (code === 0) {
          resolve({
            stdout,
            stderr,
            executionTime
          });
        } else {
          reject(new Error(`Process exited with code ${code}: ${stderr}`));
        }
      });
      
      // Handle errors
      childProcess.on('error', (error) => {
        // Remove from tracking
        this.runningProcesses.delete(executionId);
        
        reject(error);
      });
      
      // Set timeout (only to prevent infinite loops/hangs)
      const timeoutId = setTimeout(() => {
        // Kill the process
        childProcess.kill();
        
        // Remove from tracking
        this.runningProcesses.delete(executionId);
        
        reject(new Error(`Execution timed out after ${timeout}ms`));
      }, timeout);
      
      // Clean up timeout on completion
      childProcess.on('close', () => {
        clearTimeout(timeoutId);
      });
      
      // Write input to stdin if provided as string
      if (inputs && inputs.stdin && typeof inputs.stdin === 'string') {
        childProcess.stdin.write(inputs.stdin);
        childProcess.stdin.end();
      } else {
        childProcess.stdin.end();
      }
    });
  }
  
  /**
   * Stop a running execution by ID
   */
  async stopExecution(executionId) {
    this.logger.info(`Stopping execution: ${executionId}`);
    
    // Check if process is running
    if (!this.runningProcesses.has(executionId)) {
      this.logger.warn(`No running process found for execution ID: ${executionId}`);
      return false;
    }
    
    const process = this.runningProcesses.get(executionId);
    
    // Kill the process
    process.kill();
    
    // Remove from tracking
    this.runningProcesses.delete(executionId);
    
    return true;
  }
  
  /**
   * Read a file from anywhere in the system (full system access)
   */
  async readFile(filePath) {
    this.logger.info(`Reading file: ${filePath}`);
    
    try {
      const content = await fs.readFile(filePath, 'utf8');
      return content;
    } catch (error) {
      this.logger.error(`Error reading file ${filePath}:`, error);
      throw error;
    }
  }
  
  /**
   * Write a file to anywhere in the system (full system access)
   */
  async writeFile(filePath, content) {
    this.logger.info(`Writing file: ${filePath}`);
    
    try {
      // Ensure directory exists
      const dirname = path.dirname(filePath);
      await fs.mkdir(dirname, { recursive: true });
      
      // Write file
      await fs.writeFile(filePath, content);
      return true;
    } catch (error) {
      this.logger.error(`Error writing file ${filePath}:`, error);
      throw error;
    }
  }
  
  /**
   * List files in any directory (full system access)
   */
  async listFiles(dirPath) {
    this.logger.info(`Listing files in directory: ${dirPath}`);
    
    try {
      const files = await fs.readdir(dirPath);
      
      // Get file stats for each file
      const fileDetails = await Promise.all(files.map(async (file) => {
        const filePath = path.join(dirPath, file);
        const stats = await fs.stat(filePath);
        
        return {
          name: file,
          path: filePath,
          size: stats.size,
          isDirectory: stats.isDirectory(),
          created: stats.birthtime,
          modified: stats.mtime
        };
      }));
      
      return fileDetails;
    } catch (error) {
      this.logger.error(`Error listing files in ${dirPath}:`, error);
      throw error;
    }
  }
  
  /**
   * Execute any system command (full system access)
   */
  async executeCommand(command, options = {}) {
    this.logger.info(`Executing system command: ${command}`);
    
    const timeout = options.timeout || this.defaultTimeout;
    
    try {
      const { stdout, stderr } = await execPromise(command, { timeout });
      return { stdout, stderr, success: true };
    } catch (error) {
      this.logger.error(`Error executing command: ${command}`, error);
      return { 
        stdout: error.stdout || '', 
        stderr: error.stderr || error.message,
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Get execution statistics
   */
  getStats() {
    return {
      executionCount: this.executionCount,
      successCount: this.successCount,
      failureCount: this.failureCount,
      successRate: this.executionCount ? (this.successCount / this.executionCount) * 100 : 0,
      activeExecutions: this.runningProcesses.size
    };
  }
  
  /**
   * Shutdown the execution environment
   */
  async shutdown() {
    this.logger.info('Shutting down Execution Environment...');
    
    // Stop all running processes
    for (const [executionId, process] of this.runningProcesses.entries()) {
      this.logger.info(`Stopping execution ${executionId}`);
      process.kill();
    }
    
    // Clear tracking
    this.runningProcesses.clear();
    
    // Update status
    this.status.initialized = false;
    this.status.ready = false;
    
    this.logger.info('Execution Environment shutdown complete');
    
    return true;
  }
}

module.exports = ExecutionEnvironment;