/**
 * Execution Environment
 * Version: 0.1.0
 * Date: 2025-03-03
 * Author: Forge, DevOps Lead
 * 
 * The Execution Environment provides a sandboxed runtime for executing code
 * generated by agents. It handles isolation, resource management, and security
 * constraints to safely run untrusted code.
 */

'use strict';

const EventEmitter = require('events');
const { exec, spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const util = require('util');
const crypto = require('crypto');
const { Readable } = require('stream');

// Promisified exec
const execPromise = util.promisify(exec);

// Supported languages and their configurations
const SUPPORTED_LANGUAGES = {
  javascript: {
    extension: 'js',
    command: 'node',
    runFile: true
  },
  typescript: {
    extension: 'ts',
    command: 'ts-node',
    runFile: true
  },
  python: {
    extension: 'py',
    command: 'python3',
    runFile: true
  },
  bash: {
    extension: 'sh',
    command: 'bash',
    runFile: true
  },
  json: {
    extension: 'json',
    command: 'cat',
    runFile: true
  },
  text: {
    extension: 'txt',
    command: 'cat',
    runFile: true
  }
};

// Execution timeouts (in milliseconds)
const EXECUTION_TIMEOUTS = {
  default: 10000,  // 10 seconds
  long: 30000,     // 30 seconds
  short: 5000      // 5 seconds
};

// Resource limits
const RESOURCE_LIMITS = {
  memory: 100 * 1024 * 1024,  // 100 MB
  fileSize: 5 * 1024 * 1024,  // 5 MB
  processes: 5                // 5 processes
};

class ExecutionEnvironment extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = options;
    this.logger = options.logger;
    
    this.baseDirectory = options.baseDirectory || './execution';
    this.tempDirectory = path.join(this.baseDirectory, 'temp');
    this.outputDirectory = path.join(this.baseDirectory, 'output');
    
    // Map to track running processes
    this.runningProcesses = new Map();
    
    // Default timeout
    this.defaultTimeout = options.defaultTimeout || EXECUTION_TIMEOUTS.default;
    
    // Execution count for metrics
    this.executionCount = 0;
    this.successCount = 0;
    this.failureCount = 0;
    
    this.status = {
      initialized: false,
      sandboxReady: false
    };
    
    this.logger.info('Execution Environment created');
  }
  
  /**
   * Initialize the execution environment
   */
  async initialize() {
    this.logger.info('Initializing Execution Environment...');
    
    try {
      // Create required directories
      await fs.mkdir(this.baseDirectory, { recursive: true });
      await fs.mkdir(this.tempDirectory, { recursive: true });
      await fs.mkdir(this.outputDirectory, { recursive: true });
      
      // Verify commands are available
      await this._verifyDependencies();
      
      this.status.initialized = true;
      this.status.sandboxReady = true;
      
      this.logger.info('Execution Environment initialized');
      
      // Emit initialization event
      this.emit('initialized', {
        baseDirectory: this.baseDirectory,
        tempDirectory: this.tempDirectory,
        outputDirectory: this.outputDirectory
      });
      
      return true;
    } catch (error) {
      this.logger.error('Failed to initialize Execution Environment:', error);
      throw error;
    }
  }
  
  /**
   * Verify that required dependencies are available
   */
  async _verifyDependencies() {
    this.logger.info('Verifying dependencies...');
    
    const requiredCommands = new Set([
      'node',
      'python3',
      'bash',
      'cat'
    ]);
    
    // Optional commands
    const optionalCommands = new Set([
      'ts-node',
      'docker'
    ]);
    
    // Check required commands
    for (const command of requiredCommands) {
      try {
        await execPromise(`which ${command}`);
        this.logger.info(`Dependency verified: ${command}`);
      } catch (error) {
        this.logger.error(`Required dependency not found: ${command}`);
        throw new Error(`Required dependency not found: ${command}`);
      }
    }
    
    // Check optional commands
    for (const command of optionalCommands) {
      try {
        await execPromise(`which ${command}`);
        this.logger.info(`Optional dependency verified: ${command}`);
      } catch (error) {
        this.logger.warn(`Optional dependency not found: ${command}`);
        
        // If ts-node is missing, remove TypeScript from supported languages
        if (command === 'ts-node') {
          delete SUPPORTED_LANGUAGES.typescript;
        }
      }
    }
    
    // Check for Docker (for more secure sandbox)
    try {
      await execPromise('docker --version');
      this.logger.info('Docker is available for secure sandboxing');
      this.dockerAvailable = true;
    } catch (error) {
      this.logger.warn('Docker not available, will use less secure execution methods');
      this.dockerAvailable = false;
    }
    
    return true;
  }
  
  /**
   * Generate a unique execution ID
   */
  _generateExecutionId() {
    return crypto.randomBytes(8).toString('hex');
  }
  
  /**
   * Create a temporary file for code execution
   */
  async _createTempFile(code, language) {
    const executionId = this._generateExecutionId();
    const langConfig = SUPPORTED_LANGUAGES[language];
    
    if (!langConfig) {
      throw new Error(`Unsupported language: ${language}`);
    }
    
    const extension = langConfig.extension;
    const filePath = path.join(this.tempDirectory, `${executionId}.${extension}`);
    
    // Write code to temp file
    await fs.writeFile(filePath, code);
    
    return {
      executionId,
      filePath
    };
  }
  
  /**
   * Clean up temporary files after execution
   */
  async _cleanupTempFiles(executionId, filePath) {
    try {
      await fs.unlink(filePath);
      this.logger.info(`Cleaned up temp file for execution ${executionId}`);
    } catch (error) {
      this.logger.warn(`Failed to clean up temp file for execution ${executionId}:`, error);
    }
  }
  
  /**
   * Execute code in a sandboxed environment
   */
  async executeCode(code, language = 'javascript', inputs = {}, options = {}) {
    this.logger.info(`Executing ${language} code...`);
    
    // Check if environment is initialized
    if (!this.status.initialized) {
      throw new Error('Execution Environment not initialized');
    }
    
    // Verify language is supported
    if (!SUPPORTED_LANGUAGES[language]) {
      throw new Error(`Unsupported language: ${language}`);
    }
    
    // Generate execution ID and create temp file
    const { executionId, filePath } = await this._createTempFile(code, language);
    
    // Increment execution count
    this.executionCount++;
    
    // Set timeout
    const timeout = options.timeout || this.defaultTimeout;
    
    // Determine execution method based on language and available tools
    let executionMethod;
    
    if (this.dockerAvailable && options.secureExecution !== false) {
      executionMethod = 'docker';
    } else {
      executionMethod = 'process';
    }
    
    this.logger.info(`Executing ${language} code (ID: ${executionId}) using ${executionMethod}`);
    
    try {
      let result;
      
      // Execute using the determined method
      if (executionMethod === 'docker') {
        result = await this._executeWithDocker(executionId, filePath, language, inputs, timeout);
      } else {
        result = await this._executeWithProcess(executionId, filePath, language, inputs, timeout);
      }
      
      // Increment success count
      this.successCount++;
      
      // Clean up temp files
      await this._cleanupTempFiles(executionId, filePath);
      
      return {
        executionId,
        success: true,
        result: result,
        language,
        executionMethod,
        executionTime: result.executionTime
      };
    } catch (error) {
      // Increment failure count
      this.failureCount++;
      
      this.logger.error(`Execution error (ID: ${executionId}):`, error);
      
      // Clean up temp files
      await this._cleanupTempFiles(executionId, filePath);
      
      return {
        executionId,
        success: false,
        error: error.message,
        language,
        executionMethod
      };
    }
  }
  
  /**
   * Execute code using a direct child process
   */
  async _executeWithProcess(executionId, filePath, language, inputs = {}, timeout) {
    return new Promise((resolve, reject) => {
      const langConfig = SUPPORTED_LANGUAGES[language];
      const command = langConfig.command;
      const args = langConfig.runFile ? [filePath] : [];
      
      // Prepare input data as environment variables
      const env = { ...process.env };
      
      // Convert inputs to environment variables
      if (inputs && typeof inputs === 'object') {
        Object.entries(inputs).forEach(([key, value]) => {
          if (typeof value === 'string') {
            env[`INPUT_${key.toUpperCase()}`] = value;
          } else {
            env[`INPUT_${key.toUpperCase()}`] = JSON.stringify(value);
          }
        });
      }
      
      // Create process
      const startTime = Date.now();
      const childProcess = spawn(command, args, {
        env,
        cwd: this.tempDirectory,
        stdio: ['pipe', 'pipe', 'pipe']
      });
      
      // Track the process
      this.runningProcesses.set(executionId, childProcess);
      
      // Set up result collection
      let stdout = '';
      let stderr = '';
      
      // Collect stdout
      childProcess.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      // Collect stderr
      childProcess.stderr.on('data', (data) => {
        stderr += data.toString();
      });
      
      // Handle process completion
      childProcess.on('close', (code) => {
        const executionTime = Date.now() - startTime;
        
        // Remove from tracking
        this.runningProcesses.delete(executionId);
        
        if (code === 0) {
          resolve({
            stdout,
            stderr,
            executionTime
          });
        } else {
          reject(new Error(`Process exited with code ${code}: ${stderr}`));
        }
      });
      
      // Handle errors
      childProcess.on('error', (error) => {
        // Remove from tracking
        this.runningProcesses.delete(executionId);
        
        reject(error);
      });
      
      // Set timeout
      const timeoutId = setTimeout(() => {
        // Kill the process
        childProcess.kill();
        
        // Remove from tracking
        this.runningProcesses.delete(executionId);
        
        reject(new Error(`Execution timed out after ${timeout}ms`));
      }, timeout);
      
      // Clean up timeout on completion
      childProcess.on('close', () => {
        clearTimeout(timeoutId);
      });
      
      // Write input to stdin if provided as string
      if (inputs && inputs.stdin && typeof inputs.stdin === 'string') {
        childProcess.stdin.write(inputs.stdin);
        childProcess.stdin.end();
      } else {
        childProcess.stdin.end();
      }
    });
  }
  
  /**
   * Execute code using Docker for better isolation
   */
  async _executeWithDocker(executionId, filePath, language, inputs = {}, timeout) {
    // Create a volume for the code file
    const fileName = path.basename(filePath);
    const containerName = `mycoderai-execution-${executionId}`;
    
    // Determine Docker image based on language
    let dockerImage;
    let commandInContainer;
    
    switch (language) {
      case 'javascript':
        dockerImage = 'node:16-alpine';
        commandInContainer = `node /code/${fileName}`;
        break;
      case 'typescript':
        dockerImage = 'node:16-alpine';
        commandInContainer = `npx ts-node /code/${fileName}`;
        break;
      case 'python':
        dockerImage = 'python:3.9-alpine';
        commandInContainer = `python /code/${fileName}`;
        break;
      case 'bash':
        dockerImage = 'alpine:latest';
        commandInContainer = `sh /code/${fileName}`;
        break;
      default:
        dockerImage = 'alpine:latest';
        commandInContainer = `cat /code/${fileName}`;
    }
    
    // Prepare docker run command with resource limits
    let dockerCommand = `docker run --name ${containerName} `;
    
    // Set memory limit
    dockerCommand += `--memory=${Math.floor(RESOURCE_LIMITS.memory / 1024 / 1024)}m `;
    
    // Set CPU limit
    dockerCommand += `--cpus=0.5 `;
    
    // Set no network for security
    dockerCommand += `--network=none `;
    
    // Read-only filesystem except for /tmp
    dockerCommand += `--read-only `;
    dockerCommand += `--tmpfs /tmp:rw,size=50m `;
    
    // Mount code file
    dockerCommand += `-v ${filePath}:/code/${fileName}:ro `;
    
    // Set timeout
    dockerCommand += `--init --rm ${dockerImage} timeout ${Math.floor(timeout / 1000)} ${commandInContainer}`;
    
    // Execute docker command
    const startTime = Date.now();
    
    try {
      const { stdout, stderr } = await execPromise(dockerCommand, { 
        timeout: timeout + 1000 // Add 1 second to allow timeout command to work
      });
      
      const executionTime = Date.now() - startTime;
      
      return {
        stdout,
        stderr,
        executionTime
      };
    } catch (error) {
      // Ensure container is removed if it still exists
      try {
        await execPromise(`docker rm -f ${containerName} 2>/dev/null || true`);
      } catch (rmError) {
        // Ignore errors when removing container
      }
      
      // Determine if it was a timeout
      if (error.signal === 'SIGTERM' || error.message.includes('timed out')) {
        throw new Error(`Execution timed out after ${timeout}ms`);
      }
      
      throw error;
    }
  }
  
  /**
   * Stop a running execution by ID
   */
  async stopExecution(executionId) {
    this.logger.info(`Stopping execution: ${executionId}`);
    
    // Check if process is running
    if (!this.runningProcesses.has(executionId)) {
      this.logger.warn(`No running process found for execution ID: ${executionId}`);
      return false;
    }
    
    const process = this.runningProcesses.get(executionId);
    
    // Kill the process
    process.kill();
    
    // Remove from tracking
    this.runningProcesses.delete(executionId);
    
    return true;
  }
  
  /**
   * Read a file from the allowed directories
   */
  async readFile(filePath) {
    this.logger.info(`Reading file: ${filePath}`);
    
    // Normalize path
    const normalizedPath = path.normalize(filePath);
    
    // Check if path is within allowed directories
    const allowedDirs = [
      this.outputDirectory,
      this.tempDirectory
    ];
    
    const isPathAllowed = allowedDirs.some(dir => 
      normalizedPath.startsWith(path.resolve(dir))
    );
    
    if (!isPathAllowed) {
      throw new Error(`Access denied: ${filePath} is outside of allowed directories`);
    }
    
    try {
      const content = await fs.readFile(normalizedPath, 'utf8');
      return content;
    } catch (error) {
      this.logger.error(`Error reading file ${filePath}:`, error);
      throw error;
    }
  }
  
  /**
   * Write a file to the allowed directories
   */
  async writeFile(filePath, content) {
    this.logger.info(`Writing file: ${filePath}`);
    
    // Normalize path
    const normalizedPath = path.normalize(filePath);
    
    // Check if path is within allowed directories
    const allowedDirs = [
      this.outputDirectory,
      this.tempDirectory
    ];
    
    const isPathAllowed = allowedDirs.some(dir => 
      normalizedPath.startsWith(path.resolve(dir))
    );
    
    if (!isPathAllowed) {
      throw new Error(`Access denied: ${filePath} is outside of allowed directories`);
    }
    
    // Check file size limit
    const contentLength = content.length;
    if (contentLength > RESOURCE_LIMITS.fileSize) {
      throw new Error(`File size limit exceeded: ${contentLength} bytes (max: ${RESOURCE_LIMITS.fileSize} bytes)`);
    }
    
    try {
      // Ensure directory exists
      const dirname = path.dirname(normalizedPath);
      await fs.mkdir(dirname, { recursive: true });
      
      // Write file
      await fs.writeFile(normalizedPath, content);
      return true;
    } catch (error) {
      this.logger.error(`Error writing file ${filePath}:`, error);
      throw error;
    }
  }
  
  /**
   * List files in a directory
   */
  async listFiles(dirPath) {
    this.logger.info(`Listing files in directory: ${dirPath}`);
    
    // Normalize path
    const normalizedPath = path.normalize(dirPath);
    
    // Check if path is within allowed directories
    const allowedDirs = [
      this.outputDirectory,
      this.tempDirectory
    ];
    
    const isPathAllowed = allowedDirs.some(dir => 
      normalizedPath.startsWith(path.resolve(dir))
    );
    
    if (!isPathAllowed) {
      throw new Error(`Access denied: ${dirPath} is outside of allowed directories`);
    }
    
    try {
      const files = await fs.readdir(normalizedPath);
      
      // Get file stats for each file
      const fileDetails = await Promise.all(files.map(async (file) => {
        const filePath = path.join(normalizedPath, file);
        const stats = await fs.stat(filePath);
        
        return {
          name: file,
          path: filePath,
          size: stats.size,
          isDirectory: stats.isDirectory(),
          created: stats.birthtime,
          modified: stats.mtime
        };
      }));
      
      return fileDetails;
    } catch (error) {
      this.logger.error(`Error listing files in ${dirPath}:`, error);
      throw error;
    }
  }
  
  /**
   * Get execution statistics
   */
  getStats() {
    return {
      executionCount: this.executionCount,
      successCount: this.successCount,
      failureCount: this.failureCount,
      successRate: this.executionCount ? (this.successCount / this.executionCount) * 100 : 0,
      activeExecutions: this.runningProcesses.size
    };
  }
  
  /**
   * Shutdown the execution environment
   */
  async shutdown() {
    this.logger.info('Shutting down Execution Environment...');
    
    // Stop all running processes
    for (const [executionId, process] of this.runningProcesses.entries()) {
      this.logger.info(`Stopping execution ${executionId}`);
      process.kill();
    }
    
    // Clear tracking
    this.runningProcesses.clear();
    
    // Update status
    this.status.initialized = false;
    this.status.sandboxReady = false;
    
    this.logger.info('Execution Environment shutdown complete');
    
    return true;
  }
}

module.exports = ExecutionEnvironment;